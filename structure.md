# Возможности ИИ для нашей работы

## Глава 0

Эта презентация сгенерирована.

## Глава 1: Повестка

- Внедрение ИИ в рабочий процесс: плюсы и минусы
- В начале 2026 г. обновлён проект e2e-тестов — открыт для экспериментов
- Сейчас в фокусе — документация (homepage)

## Глава 2: Дока — история вопроса

- Год назад предлагалось реструктурировать проектную документацию (homepage):
  1. Пользовательская документация: RST -> Markdown
  2. Методы API: перевод в JSON по спецификации OpenAPI

## Глава 3: Зачем это нужно?

- Единый проект со сквозным поиском вместо разрозненных источников
- Markdown: прост в освоении, низкий порог входа, широкая поддержка инструментов
- OpenAPI — машиночитаемый стандарт описания API. Экосистема готовых инструментов (tools.openapis.org):
  - Интерактивная документация (Redoc, Swagger UI) — живой интерфейс с поиском, фильтрацией, примерами запросов
  - Автоматическая проверка: реальное поведение сервера сверяется с документацией — ошибки ловятся до пользователя
  - Генерация клиентского кода: готовые функции для фронтенда создаются автоматически
  - Единый формат, понятный всем — от фронтенда до QA

## Глава 4: Почему отказались год назад?

- Организационная проблема: слишком большой объём ручной работы
- Техническая проблема: радикальное изменение workflow бэкенд-разработчиков — они не согласились

## Глава 5: Что изменилось в 2026-ом?



## Глава 6: Чем это обеспечено?

- open_api_generator.py — 2 394 строки Python-кода
- Генерирует OpenAPI-спецификацию из существующих исходников, не требуя изменений от бэкенд-разработчиков
- Парсит 5 типов источников:
  - RST-документация
  - Описания функций в коде
  - Файлы маршрутов
  - Примеры HTTP-запросов
  - Конфигурация проекта
- На выходе — готовый файл для Redoc / Swagger UI

## Глава 7: Реализация парсера — вводные

- 272 эндпоинта API в двух проектах (ostecPlatform — 147, smartLine — 125)
- Отсутствие единого стиля оформления — за годы разные разработчики описывали API по-разному:
  - Параметры: маркированные списки / таблицы / JSON без пояснений
  - Форматы: структурированный Sphinx vs свободный текст
  - Даже стиль кавычек отличается от файла к файлу
- Структурные различия между проектами:
  - Конфигурация: config/ vs conf/; один файл vs 13 отдельных
  - Формат маршрутов: простая строка vs массив с HTTP-методами
  - Таблицы моделей данных: есть в одном проекте, нет в другом
- Итог: утилита должна распознавать и корректно обрабатывать все варианты

## Глава 8: А если без ИИ?

- Нет готовых решений под наши вводные — придётся писать всё с нуля
- Большой объём кропотливой работы с низкоуровневым кодом парсера
- Требуется учесть все нюансы разных стилей оформления
- Самописный парсер тяжело поддерживать

- Итог: без ИИ такая задача — за гранью наших возможностей

## Глава 9: Применение на наших проектах

- Стандартные — широко используются готовые решения:
  - Web: backend / frontend / тесты / документация
  - Мобильные приложения
  - Bitrix
  - Apache Superset
- Нестандартные — нет готовых решений, создание ноу-хау:
  - СТЗ (алгоритмы)

## Глава 10: СТЗ — вводные

- Для СТЗ (в части алгоритмов) справедливо то же, что для парсера:
  - Нет готовых рецептов под наши вводные
  - Большой объём кропотливой работы
  - Множество нестандартных случаев
  - Часть потенциальных проблем возможно ещё не осознана

## Глава 11: СТЗ с ИИ

- Трудоёмкий перевод гипотез в код делегируется ИИ
- Человек высвобождается для интеллектуальной и творческой деятельности
- Плюсы и минусы:
  - "+": Высокая скорость проверки разнообразных гипотез
  - "+": Раннее обнаружение ошибок в логике, которые человек может пропустить
  - "-": Сгенерированные алгоритмы сложны для человеческого восприятия
  - "+": Логика алгоритмов дублируется в виде текста, понятного человеку
- Вывод: имеет смысл пожертвовать читаемостью кода в пользу скорости обнаружения оптимальных решений

## Глава 12: Стандартные проекты — мелкие

- Проекты без сложной бизнес-логики (умные часы, панель, ...)
- Возможен переход к Spec-Driven Development

- Spec-Driven Development — подход, при котором сначала пишется формальная спецификация (контракт поведения системы), а затем ИИ-агент генерирует код по ней. Инверсия классического процесса: не «код, потом документация», а «спецификация — и код как генерируемый артефакт». Спецификация даёт ИИ чёткий ориентир, не позволяя ему терять контекст и генерировать противоречивый код.

- Преимущества:
  - Человек освобождён от кодирования
  - Независимость от конкретного варианта текущей реализации
  - Простота обновлений на новые мажорные версии библиотек

## Глава 13: Стандартные проекты — крупные

- На крупных проектах избыточное использование ИИ несёт риск потери контроля над разработкой. Использовать с осторожностью!

- Исключение: e2e-тесты, Playwright. AI-driven тестирование — уже стандартная история. Позволяет человеческим языком описывать атомарные операции с системными сущностями и собирать из них пользовательские сценарии как из конструктора.

## Глава 14: Безопасность

- Стандартное требование — код не должен содержать чувствительной или секретной информации. В противном случае украсть её может и рядовой сотрудник.

- Есть возможность настройки прав доступа к файлам для ИИ-агента:
  - `~/.claude/settings.json`
  - `.claudeignore`

## Глава 15: Итог

- Максимальное преимущество от ИИ — на больших, сложных, нестандартных проектах
- В рамках обычных задач — облегчает рутину
- Тарифы Anthropic:
  - Pro: $20/мес — доступ к Claude Code, базовые лимиты
  - Max 5x: $100/мес — 5-кратные лимиты, фоновые задачи для агента
  - Max 20x: $200/мес — 20-кратные лимиты, максимальный приоритет
  - Team: от $25/мес за стандартное место, $150/мес за место с Claude Code
  - Enterprise: индивидуальные условия, расширенный контроль безопасности

## Глава 16: Дополнение* — RAG

- RAG (Retrieval-Augmented Generation) — единое окно доступа ко всем знаниям компании через ИИ
- Все данные хранятся во внутреннем контуре, ничего не отправляется третьим лицам
- Доступ разграничивается — сотрудник видит только документы, к которым у него есть права
- Роль ИИ:
  - Синтез — собирает ответ из нескольких документов в один связный текст, соответствующий намерениям пользователя
  - Диалог — можно уточнять, переспрашивать, углублять вопрос
- Снижение bus factor: RAG делает знания из документов доступными всем, а не только тем, кто «знает, где искать» или «знает, кого спросить»
